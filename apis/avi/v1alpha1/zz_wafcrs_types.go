/*
Copyright 2022 Upbound Inc.
*/

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ExcludeListClientSubnetIPAddrInitParameters struct {
	Addr *string `json:"addr,omitempty" tf:"addr,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ExcludeListClientSubnetIPAddrObservation struct {
	Addr *string `json:"addr,omitempty" tf:"addr,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type ExcludeListClientSubnetIPAddrParameters struct {

	// +kubebuilder:validation:Optional
	Addr *string `json:"addr" tf:"addr,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type ExcludeListClientSubnetInitParameters struct {
	IPAddr []ExcludeListClientSubnetIPAddrInitParameters `json:"ipAddr,omitempty" tf:"ip_addr,omitempty"`

	Mask *string `json:"mask,omitempty" tf:"mask,omitempty"`
}

type ExcludeListClientSubnetObservation struct {
	IPAddr []ExcludeListClientSubnetIPAddrObservation `json:"ipAddr,omitempty" tf:"ip_addr,omitempty"`

	Mask *string `json:"mask,omitempty" tf:"mask,omitempty"`
}

type ExcludeListClientSubnetParameters struct {

	// +kubebuilder:validation:Optional
	IPAddr []ExcludeListClientSubnetIPAddrParameters `json:"ipAddr" tf:"ip_addr,omitempty"`

	// +kubebuilder:validation:Optional
	Mask *string `json:"mask" tf:"mask,omitempty"`
}

type ExcludeListMatchElementCriteriaInitParameters struct {
	MatchCase *string `json:"matchCase,omitempty" tf:"match_case,omitempty"`

	MatchOp *string `json:"matchOp,omitempty" tf:"match_op,omitempty"`
}

type ExcludeListMatchElementCriteriaObservation struct {
	MatchCase *string `json:"matchCase,omitempty" tf:"match_case,omitempty"`

	MatchOp *string `json:"matchOp,omitempty" tf:"match_op,omitempty"`
}

type ExcludeListMatchElementCriteriaParameters struct {

	// +kubebuilder:validation:Optional
	MatchCase *string `json:"matchCase,omitempty" tf:"match_case,omitempty"`

	// +kubebuilder:validation:Optional
	MatchOp *string `json:"matchOp,omitempty" tf:"match_op,omitempty"`
}

type ExcludeListURIMatchCriteriaInitParameters struct {
	MatchCase *string `json:"matchCase,omitempty" tf:"match_case,omitempty"`

	MatchOp *string `json:"matchOp,omitempty" tf:"match_op,omitempty"`
}

type ExcludeListURIMatchCriteriaObservation struct {
	MatchCase *string `json:"matchCase,omitempty" tf:"match_case,omitempty"`

	MatchOp *string `json:"matchOp,omitempty" tf:"match_op,omitempty"`
}

type ExcludeListURIMatchCriteriaParameters struct {

	// +kubebuilder:validation:Optional
	MatchCase *string `json:"matchCase,omitempty" tf:"match_case,omitempty"`

	// +kubebuilder:validation:Optional
	MatchOp *string `json:"matchOp,omitempty" tf:"match_op,omitempty"`
}

type GroupsExcludeListInitParameters struct {
	ClientSubnet []ExcludeListClientSubnetInitParameters `json:"clientSubnet,omitempty" tf:"client_subnet,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	MatchElement *string `json:"matchElement,omitempty" tf:"match_element,omitempty"`

	MatchElementCriteria []ExcludeListMatchElementCriteriaInitParameters `json:"matchElementCriteria,omitempty" tf:"match_element_criteria,omitempty"`

	URIMatchCriteria []ExcludeListURIMatchCriteriaInitParameters `json:"uriMatchCriteria,omitempty" tf:"uri_match_criteria,omitempty"`

	URIPath *string `json:"uriPath,omitempty" tf:"uri_path,omitempty"`
}

type GroupsExcludeListObservation struct {
	ClientSubnet []ExcludeListClientSubnetObservation `json:"clientSubnet,omitempty" tf:"client_subnet,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	MatchElement *string `json:"matchElement,omitempty" tf:"match_element,omitempty"`

	MatchElementCriteria []ExcludeListMatchElementCriteriaObservation `json:"matchElementCriteria,omitempty" tf:"match_element_criteria,omitempty"`

	URIMatchCriteria []ExcludeListURIMatchCriteriaObservation `json:"uriMatchCriteria,omitempty" tf:"uri_match_criteria,omitempty"`

	URIPath *string `json:"uriPath,omitempty" tf:"uri_path,omitempty"`
}

type GroupsExcludeListParameters struct {

	// +kubebuilder:validation:Optional
	ClientSubnet []ExcludeListClientSubnetParameters `json:"clientSubnet,omitempty" tf:"client_subnet,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	MatchElement *string `json:"matchElement,omitempty" tf:"match_element,omitempty"`

	// +kubebuilder:validation:Optional
	MatchElementCriteria []ExcludeListMatchElementCriteriaParameters `json:"matchElementCriteria,omitempty" tf:"match_element_criteria,omitempty"`

	// +kubebuilder:validation:Optional
	URIMatchCriteria []ExcludeListURIMatchCriteriaParameters `json:"uriMatchCriteria,omitempty" tf:"uri_match_criteria,omitempty"`

	// +kubebuilder:validation:Optional
	URIPath *string `json:"uriPath,omitempty" tf:"uri_path,omitempty"`
}

type GroupsRulesInitParameters struct {
	Enable *string `json:"enable,omitempty" tf:"enable,omitempty"`

	ExcludeList []RulesExcludeListInitParameters `json:"excludeList,omitempty" tf:"exclude_list,omitempty"`

	Index *string `json:"index,omitempty" tf:"index,omitempty"`

	IsSensitive *string `json:"isSensitive,omitempty" tf:"is_sensitive,omitempty"`

	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	ParanoiaLevel *string `json:"paranoiaLevel,omitempty" tf:"paranoia_level,omitempty"`

	Phase *string `json:"phase,omitempty" tf:"phase,omitempty"`

	Rule *string `json:"rule,omitempty" tf:"rule,omitempty"`

	RuleID *string `json:"ruleId,omitempty" tf:"rule_id,omitempty"`

	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type GroupsRulesObservation struct {
	Enable *string `json:"enable,omitempty" tf:"enable,omitempty"`

	ExcludeList []RulesExcludeListObservation `json:"excludeList,omitempty" tf:"exclude_list,omitempty"`

	Index *string `json:"index,omitempty" tf:"index,omitempty"`

	IsSensitive *string `json:"isSensitive,omitempty" tf:"is_sensitive,omitempty"`

	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	ParanoiaLevel *string `json:"paranoiaLevel,omitempty" tf:"paranoia_level,omitempty"`

	Phase *string `json:"phase,omitempty" tf:"phase,omitempty"`

	Rule *string `json:"rule,omitempty" tf:"rule,omitempty"`

	RuleID *string `json:"ruleId,omitempty" tf:"rule_id,omitempty"`

	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type GroupsRulesParameters struct {

	// +kubebuilder:validation:Optional
	Enable *string `json:"enable,omitempty" tf:"enable,omitempty"`

	// +kubebuilder:validation:Optional
	ExcludeList []RulesExcludeListParameters `json:"excludeList,omitempty" tf:"exclude_list,omitempty"`

	// +kubebuilder:validation:Optional
	Index *string `json:"index" tf:"index,omitempty"`

	// +kubebuilder:validation:Optional
	IsSensitive *string `json:"isSensitive,omitempty" tf:"is_sensitive,omitempty"`

	// +kubebuilder:validation:Optional
	Mode *string `json:"mode,omitempty" tf:"mode,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	ParanoiaLevel *string `json:"paranoiaLevel,omitempty" tf:"paranoia_level,omitempty"`

	// +kubebuilder:validation:Optional
	Phase *string `json:"phase,omitempty" tf:"phase,omitempty"`

	// +kubebuilder:validation:Optional
	Rule *string `json:"rule" tf:"rule,omitempty"`

	// +kubebuilder:validation:Optional
	RuleID *string `json:"ruleId,omitempty" tf:"rule_id,omitempty"`

	// +kubebuilder:validation:Optional
	Tags []*string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type RulesExcludeListClientSubnetIPAddrInitParameters struct {
	Addr *string `json:"addr,omitempty" tf:"addr,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type RulesExcludeListClientSubnetIPAddrObservation struct {
	Addr *string `json:"addr,omitempty" tf:"addr,omitempty"`

	Type *string `json:"type,omitempty" tf:"type,omitempty"`
}

type RulesExcludeListClientSubnetIPAddrParameters struct {

	// +kubebuilder:validation:Optional
	Addr *string `json:"addr" tf:"addr,omitempty"`

	// +kubebuilder:validation:Optional
	Type *string `json:"type" tf:"type,omitempty"`
}

type RulesExcludeListClientSubnetInitParameters struct {
	IPAddr []RulesExcludeListClientSubnetIPAddrInitParameters `json:"ipAddr,omitempty" tf:"ip_addr,omitempty"`

	Mask *string `json:"mask,omitempty" tf:"mask,omitempty"`
}

type RulesExcludeListClientSubnetObservation struct {
	IPAddr []RulesExcludeListClientSubnetIPAddrObservation `json:"ipAddr,omitempty" tf:"ip_addr,omitempty"`

	Mask *string `json:"mask,omitempty" tf:"mask,omitempty"`
}

type RulesExcludeListClientSubnetParameters struct {

	// +kubebuilder:validation:Optional
	IPAddr []RulesExcludeListClientSubnetIPAddrParameters `json:"ipAddr" tf:"ip_addr,omitempty"`

	// +kubebuilder:validation:Optional
	Mask *string `json:"mask" tf:"mask,omitempty"`
}

type RulesExcludeListInitParameters struct {
	ClientSubnet []RulesExcludeListClientSubnetInitParameters `json:"clientSubnet,omitempty" tf:"client_subnet,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	MatchElement *string `json:"matchElement,omitempty" tf:"match_element,omitempty"`

	MatchElementCriteria []RulesExcludeListMatchElementCriteriaInitParameters `json:"matchElementCriteria,omitempty" tf:"match_element_criteria,omitempty"`

	URIMatchCriteria []RulesExcludeListURIMatchCriteriaInitParameters `json:"uriMatchCriteria,omitempty" tf:"uri_match_criteria,omitempty"`

	URIPath *string `json:"uriPath,omitempty" tf:"uri_path,omitempty"`
}

type RulesExcludeListMatchElementCriteriaInitParameters struct {
	MatchCase *string `json:"matchCase,omitempty" tf:"match_case,omitempty"`

	MatchOp *string `json:"matchOp,omitempty" tf:"match_op,omitempty"`
}

type RulesExcludeListMatchElementCriteriaObservation struct {
	MatchCase *string `json:"matchCase,omitempty" tf:"match_case,omitempty"`

	MatchOp *string `json:"matchOp,omitempty" tf:"match_op,omitempty"`
}

type RulesExcludeListMatchElementCriteriaParameters struct {

	// +kubebuilder:validation:Optional
	MatchCase *string `json:"matchCase,omitempty" tf:"match_case,omitempty"`

	// +kubebuilder:validation:Optional
	MatchOp *string `json:"matchOp,omitempty" tf:"match_op,omitempty"`
}

type RulesExcludeListObservation struct {
	ClientSubnet []RulesExcludeListClientSubnetObservation `json:"clientSubnet,omitempty" tf:"client_subnet,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	MatchElement *string `json:"matchElement,omitempty" tf:"match_element,omitempty"`

	MatchElementCriteria []RulesExcludeListMatchElementCriteriaObservation `json:"matchElementCriteria,omitempty" tf:"match_element_criteria,omitempty"`

	URIMatchCriteria []RulesExcludeListURIMatchCriteriaObservation `json:"uriMatchCriteria,omitempty" tf:"uri_match_criteria,omitempty"`

	URIPath *string `json:"uriPath,omitempty" tf:"uri_path,omitempty"`
}

type RulesExcludeListParameters struct {

	// +kubebuilder:validation:Optional
	ClientSubnet []RulesExcludeListClientSubnetParameters `json:"clientSubnet,omitempty" tf:"client_subnet,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	MatchElement *string `json:"matchElement,omitempty" tf:"match_element,omitempty"`

	// +kubebuilder:validation:Optional
	MatchElementCriteria []RulesExcludeListMatchElementCriteriaParameters `json:"matchElementCriteria,omitempty" tf:"match_element_criteria,omitempty"`

	// +kubebuilder:validation:Optional
	URIMatchCriteria []RulesExcludeListURIMatchCriteriaParameters `json:"uriMatchCriteria,omitempty" tf:"uri_match_criteria,omitempty"`

	// +kubebuilder:validation:Optional
	URIPath *string `json:"uriPath,omitempty" tf:"uri_path,omitempty"`
}

type RulesExcludeListURIMatchCriteriaInitParameters struct {
	MatchCase *string `json:"matchCase,omitempty" tf:"match_case,omitempty"`

	MatchOp *string `json:"matchOp,omitempty" tf:"match_op,omitempty"`
}

type RulesExcludeListURIMatchCriteriaObservation struct {
	MatchCase *string `json:"matchCase,omitempty" tf:"match_case,omitempty"`

	MatchOp *string `json:"matchOp,omitempty" tf:"match_op,omitempty"`
}

type RulesExcludeListURIMatchCriteriaParameters struct {

	// +kubebuilder:validation:Optional
	MatchCase *string `json:"matchCase,omitempty" tf:"match_case,omitempty"`

	// +kubebuilder:validation:Optional
	MatchOp *string `json:"matchOp,omitempty" tf:"match_op,omitempty"`
}

type WafCrsConfigpbAttributesInitParameters struct {
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type WafCrsConfigpbAttributesObservation struct {
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type WafCrsConfigpbAttributesParameters struct {

	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type WafCrsGroupsInitParameters struct {
	Enable *string `json:"enable,omitempty" tf:"enable,omitempty"`

	ExcludeList []GroupsExcludeListInitParameters `json:"excludeList,omitempty" tf:"exclude_list,omitempty"`

	Index *string `json:"index,omitempty" tf:"index,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Rules []GroupsRulesInitParameters `json:"rules,omitempty" tf:"rules,omitempty"`
}

type WafCrsGroupsObservation struct {
	Enable *string `json:"enable,omitempty" tf:"enable,omitempty"`

	ExcludeList []GroupsExcludeListObservation `json:"excludeList,omitempty" tf:"exclude_list,omitempty"`

	Index *string `json:"index,omitempty" tf:"index,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	Rules []GroupsRulesObservation `json:"rules,omitempty" tf:"rules,omitempty"`
}

type WafCrsGroupsParameters struct {

	// +kubebuilder:validation:Optional
	Enable *string `json:"enable,omitempty" tf:"enable,omitempty"`

	// +kubebuilder:validation:Optional
	ExcludeList []GroupsExcludeListParameters `json:"excludeList,omitempty" tf:"exclude_list,omitempty"`

	// +kubebuilder:validation:Optional
	Index *string `json:"index" tf:"index,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	Rules []GroupsRulesParameters `json:"rules,omitempty" tf:"rules,omitempty"`
}

type WafCrsInitParameters struct {
	ConfigpbAttributes []WafCrsConfigpbAttributesInitParameters `json:"configpbAttributes,omitempty" tf:"configpb_attributes,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	Groups []WafCrsGroupsInitParameters `json:"groups,omitempty" tf:"groups,omitempty"`

	Integrity *string `json:"integrity,omitempty" tf:"integrity,omitempty"`

	Markers []WafCrsMarkersInitParameters `json:"markers,omitempty" tf:"markers,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	ReleaseDate *string `json:"releaseDate,omitempty" tf:"release_date,omitempty"`

	TenantRef *string `json:"tenantRef,omitempty" tf:"tenant_ref,omitempty"`

	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`

	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type WafCrsMarkersInitParameters struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type WafCrsMarkersObservation struct {
	Key *string `json:"key,omitempty" tf:"key,omitempty"`

	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type WafCrsMarkersParameters struct {

	// +kubebuilder:validation:Optional
	Key *string `json:"key" tf:"key,omitempty"`

	// +kubebuilder:validation:Optional
	Values []*string `json:"values,omitempty" tf:"values,omitempty"`
}

type WafCrsObservation struct {
	ConfigpbAttributes []WafCrsConfigpbAttributesObservation `json:"configpbAttributes,omitempty" tf:"configpb_attributes,omitempty"`

	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	Groups []WafCrsGroupsObservation `json:"groups,omitempty" tf:"groups,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	Integrity *string `json:"integrity,omitempty" tf:"integrity,omitempty"`

	Markers []WafCrsMarkersObservation `json:"markers,omitempty" tf:"markers,omitempty"`

	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	ReleaseDate *string `json:"releaseDate,omitempty" tf:"release_date,omitempty"`

	TenantRef *string `json:"tenantRef,omitempty" tf:"tenant_ref,omitempty"`

	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`

	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

type WafCrsParameters struct {

	// +kubebuilder:validation:Optional
	ConfigpbAttributes []WafCrsConfigpbAttributesParameters `json:"configpbAttributes,omitempty" tf:"configpb_attributes,omitempty"`

	// +kubebuilder:validation:Optional
	Description *string `json:"description,omitempty" tf:"description,omitempty"`

	// +kubebuilder:validation:Optional
	Groups []WafCrsGroupsParameters `json:"groups,omitempty" tf:"groups,omitempty"`

	// +kubebuilder:validation:Optional
	Integrity *string `json:"integrity,omitempty" tf:"integrity,omitempty"`

	// +kubebuilder:validation:Optional
	Markers []WafCrsMarkersParameters `json:"markers,omitempty" tf:"markers,omitempty"`

	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// +kubebuilder:validation:Optional
	ReleaseDate *string `json:"releaseDate,omitempty" tf:"release_date,omitempty"`

	// +kubebuilder:validation:Optional
	TenantRef *string `json:"tenantRef,omitempty" tf:"tenant_ref,omitempty"`

	// +kubebuilder:validation:Optional
	UUID *string `json:"uuid,omitempty" tf:"uuid,omitempty"`

	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version,omitempty"`
}

// WafCrsSpec defines the desired state of WafCrs
type WafCrsSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     WafCrsParameters `json:"forProvider"`
	// THIS IS AN ALPHA FIELD. Do not use it in production. It is not honored
	// unless the relevant Crossplane feature flag is enabled, and may be
	// changed or removed without notice.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider WafCrsInitParameters `json:"initProvider,omitempty"`
}

// WafCrsStatus defines the observed state of WafCrs.
type WafCrsStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        WafCrsObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// WafCrs is the Schema for the WafCrss API. <no value>
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,avi}
type WafCrs struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.description) || has(self.initProvider.description)",message="description is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.integrity) || has(self.initProvider.integrity)",message="integrity is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || has(self.initProvider.name)",message="name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.releaseDate) || has(self.initProvider.releaseDate)",message="releaseDate is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.version) || has(self.initProvider.version)",message="version is a required parameter"
	Spec   WafCrsSpec   `json:"spec"`
	Status WafCrsStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// WafCrsList contains a list of WafCrss
type WafCrsList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []WafCrs `json:"items"`
}

// Repository type metadata.
var (
	WafCrs_Kind             = "WafCrs"
	WafCrs_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: WafCrs_Kind}.String()
	WafCrs_KindAPIVersion   = WafCrs_Kind + "." + CRDGroupVersion.String()
	WafCrs_GroupVersionKind = CRDGroupVersion.WithKind(WafCrs_Kind)
)

func init() {
	SchemeBuilder.Register(&WafCrs{}, &WafCrsList{})
}
